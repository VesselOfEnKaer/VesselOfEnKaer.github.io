<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>GER40 — Candles</title>

  <style>
    :root {
      --bg: #f8fafc;
      --card: #ffffff;
      --border: #e5e7eb;
      --text: #111827;
      --muted: #6b7280;
      --accent: #2563eb;
      --green: #22c55e;
      --red: #ef4444;
    }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font: 14px/1.5 "Inter", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 28px;
      background: var(--card);
      border-bottom: 1px solid var(--border);
      box-shadow: 0 2px 6px rgba(0,0,0,.03);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    #title { font-weight: 600; font-size: 16px; }
    #subtitle { color: var(--muted); font-size: 13px; }
    main {
      flex: 1;
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 20px;
      padding: 24px;
      max-width: 1400px;
      margin: 0 auto;
      width: 100%;
      box-sizing: border-box;
    }
    section {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,.04);
    }
    #chart { height: 70vh; }
    h2 {
      margin: 0 0 10px;
      font-size: 15px;
      font-weight: 600;
      color: var(--text);
    }
    p { margin: 0 0 8px; color: var(--muted); font-size: 13px; }
    .btn {
      border: 1px solid var(--border);
      padding: 8px 14px;
      border-radius: 10px;
      cursor: pointer;
      background: var(--card);
      color: var(--text);
      transition: all .15s;
    }
    .btn:hover { border-color: var(--accent); color: var(--accent); }
    footer {
      text-align: center;
      font-size: 12px;
      color: var(--muted);
      padding: 14px 0 20px;
    }
    #err {
      color: var(--red);
      white-space: pre-wrap;
      font-family: ui-monospace, Menlo, Consolas, monospace;
      margin-top: 10px;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
</head>
<body>
<header>
  <div>
    <div id="title">Загрузка…</div>
    <div id="subtitle">Ожидаем данные</div>
  </div>
  <button id="copyLinkBtn" class="btn">Скопировать ссылку</button>
</header>

<main>
  <section>
    <div id="chart"></div>
    <div id="err" style="display:none"></div>
  </section>
  <section>
    <h2>Параметры</h2>
    <p>Ссылка содержит зашифрованный JSON со свечами (time, open, high, low, close).<br>
    Наведи курсор по свечам, чтобы увидеть значения.</p>
    <h2>Сводка</h2>
    <p id="stats" class="muted">–</p>
  </section>
</main>

<footer>© 2025 GER40 Viewer • GitHub Pages</footer>

<script>
  const qs = new URLSearchParams(location.search);
  const $ = id => document.getElementById(id);

  function showError(msg) {
    $('err').style.display = 'block';
    $('err').textContent = msg;
    $('title').textContent = 'Ошибка';
    $('subtitle').textContent = msg;
  }

  function b64urlToBytes(b64u) {
    const b64 = (b64u||'').replace(/-/g,'+').replace(/_/g,'/');
    const pad = b64.length%4 ? 4-(b64.length%4):0;
    const bin = atob(b64+'='.repeat(pad));
    return Uint8Array.from(bin, c=>c.charCodeAt(0));
  }

  function parsePayload() {
    if (qs.get('demo')==='1') {
      const start=new Date('2025-01-01');
      const candles=Array.from({length:30},(_,i)=>{
        const d=new Date(start.getTime()+i*86400000);
        const o=17000+i*10, h=o+70, l=o-50, c=o+(i%2?30:-20);
        return {time:d.toISOString().slice(0,10),open:o,high:h,low:l,close:c};
      });
      return {symbol:'DEMO',exchange:'TEST',timeframe:'1D',candles};
    }
    const d=qs.get('d'), j=qs.get('j');
    try{
      if(d){
        const infl=pako.inflate(b64urlToBytes(d));
        return JSON.parse(new TextDecoder().decode(infl));
      }
      if(j){return JSON.parse(decodeURIComponent(j));}
    }catch(e){showError('Ошибка разбора: '+e.message);}
    return null;
  }

  function summarize(candles){
    const f=candles[0],l=candles.at(-1);
    const min=Math.min(...candles.map(c=>c.low));
    const max=Math.max(...candles.map(c=>c.high));
    const change=((l.close-f.open)/f.open*100).toFixed(2);
    return `Период: ${f.time} → ${l.time}<br>Мин/Макс: ${min.toFixed(2)} / ${max.toFixed(2)}<br>Изм.: ${change}%`;
  }

  function renderChart(payload) {
  const container = $('chart');

  // на время анимации отключаем жесты
  const chart = LightweightCharts.createChart(container, {
    autoSize: true,
    layout: { background: { type: 'solid', color: '#ffffff' }, textColor: '#111' },
    grid: { vertLines: { color: 'rgba(0,0,0,.05)' }, horzLines: { color: 'rgba(0,0,0,.05)' } },
    rightPriceScale: { borderVisible: false },
    timeScale: { borderVisible: false, rightOffset: 0, barSpacing: 8, fixLeftEdge: true },
    handleScroll: { mouseWheel: false, pressedMouseMove: false, horzTouchDrag: false },
    handleScale:  { axisPressedMouseMove: false, mouseWheel: false, pinch: false },
    crosshair: { mode: LightweightCharts.CrosshairMode.Normal }
  });

  const series = chart.addCandlestickSeries({
    upColor:'#22c55e', downColor:'#ef4444',
    borderUpColor:'#16a34a', borderDownColor:'#dc2626',
    wickUpColor:'#16a34a', wickDownColor:'#dc2626',
  });

  const src = payload.candles;
  if (!Array.isArray(src) || !src.length) throw new Error('Нет данных');

  // ---------- параметры анимации ----------
  const DURATION_MS = 400;  // длительность роста ОДНОГО бара
  const STAGGER_MS  = 100;  // задержка старта следующего бара
  const MAX_OVERLAP = 4;    // максимум одновременно «живых» баров (визуально ≈ DURATION/STAGGER)

  // плавность (как раньше): soft/bounce/elastic/linear
  const EASE = {
    linear:  t => t,
    soft:    t => 1 - Math.pow(1 - t, 3),
    bounce:  t => { const c1=1.70158,c3=c1+1; return 1 + c3*Math.pow(t-1,3) + c1*Math.pow(t-1,2); },
    elastic: t => { const c4=(2*Math.PI)/3; return t===0?0:t===1?1:Math.pow(2,-10*t)*Math.sin((t*10-0.75)*c4)+1; }
  };
  const ease = EASE.soft;

  // фиксируем левый край на первой свече, расширяем правую границу
  const baseWin = Math.min(80, Math.max(10, src.length - 1));
  chart.timeScale().setVisibleLogicalRange({ from: 0, to: Math.max(1, baseWin) });

  // стартовое состояние (ничего не нарисовано)
  series.setData([]);

  // «конвейер»: бар i стартует в момент t0 + i*STAGGER_MS
  const t0 = performance.now();

  function frame(now) {
    const elapsed = now - t0;

    // индекс последнего, кто УЖЕ должен начать анимацию
    const lastShouldStart = Math.min(
      src.length - 1,
      Math.floor(elapsed / STAGGER_MS)
    );

    if (lastShouldStart < 0) { requestAnimationFrame(frame); return; }

    // ограничим глубину, чтобы не анимировать слишком много одновременно
    const firstActive = Math.max(0, lastShouldStart - (MAX_OVERLAP - 1));

    // соберём массив на кадр: все готовые бары + активные с промежуточными значениями
    const frameData = [];

    // готовые (законченные) бары до firstActive
    for (let i = 0; i < firstActive; i++) frameData.push(src[i]);

    // активные бары (firstActive..lastShouldStart)
    let lastVisibleIndex = firstActive - 1;
    for (let i = firstActive; i <= lastShouldStart; i++) {
      const startTime = t0 + i * STAGGER_MS;
      const t = Math.min(1, (now - startTime) / DURATION_MS);
      const k = ease(Math.max(0, t)); // 0..1

      const tgt = src[i];
      const open = +tgt.open;
      // тело растёт от open к close, тени — к high/low
      let close = open + (tgt.close - open) * k;

      const baseHigh = Math.max(open, close);
      const baseLow  = Math.min(open, close);
      let high = baseHigh + (tgt.high - baseHigh) * k;
      let low  = baseLow  + (tgt.low  - baseLow ) * k;

      // инварианты (на случай оверсута у bounce/elastic)
      if (low > Math.min(open, close))  low  = Math.min(open, close);
      if (high < Math.max(open, close)) high = Math.max(open, close);

      frameData.push({ time: tgt.time, open, high, low, close });
      lastVisibleIndex = i;
    }

    // setData рисует сразу весь хвост до последнего активного бара
    series.setData(frameData);

    // расширяем правую границу окна, левую держим на 0
    const right = Math.max(baseWin, lastVisibleIndex + 0.999);
    chart.timeScale().setVisibleLogicalRange({ from: 0, to: right });

    // завершение: когда отрисован последний и его k==1
    const lastDone = elapsed >= (src.length - 1) * STAGGER_MS + DURATION_MS;
    if (!lastDone) {
      requestAnimationFrame(frame);
    } else {
      // финальная фиксация точных данных и возврат жестов
      series.setData(src);
      chart.applyOptions({
        handleScroll: { mouseWheel: true, pressedMouseMove: true, horzTouchDrag: true },
        handleScale:  { axisPressedMouseMove: true, mouseWheel: true, pinch: true },
      });
      chart.timeScale().fitContent();
    }
  }

  requestAnimationFrame(frame);

  // заголовок/сводка
  $('title').textContent = (payload.symbol || 'GER40') + ' — дневные свечи';
  $('subtitle').textContent =
    (payload.exchange || 'FOREXCOM') + ' • ' + (payload.timeframe || '1D') +
    ' • баров: ' + src.length;
  $('stats').innerHTML = summarize(src);
}
  

  document.addEventListener('DOMContentLoaded',()=>{
    $('copyLinkBtn').addEventListener('click',async()=>{
      try{await navigator.clipboard.writeText(location.href);}catch{}
      const b=$('copyLinkBtn'); const t=b.textContent;
      b.textContent='Скопировано!'; setTimeout(()=>b.textContent=t,1000);
    });
    const p=parsePayload();
    if(!p){$('subtitle').textContent='Нет данных (?demo=1 для теста)';return;}
    try{renderChart(p);}catch(e){showError(e.message);}
  });
</script>
</body>
</html>
